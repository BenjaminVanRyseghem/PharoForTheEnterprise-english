!Checking and Transforming Programs with Rewrite rules




!!Basic Knowledge on AST and other concepts

An abstract syntax tree or AST is a data structure that is semantically equivalent to some source code. While source code is just a string of characters, an AST is a tree whose nodes correspond to the syntactic constructs of the parsed language. In Smalltalk, an AST node can represent a message, a method, a variable, a block, an assignment, etc... Such a tree is much easier to process than a plain string. That is why this data structure is used by most tools that have to deal with code like the compiler or in the context of this chapter, the code rewriter. 

Lets met our first AST. Consider the following method. 

[[[
< aPoint 
	"Answer whether the receiver is above and to the left of aPoint."

	^x < aPoint x and: [y < aPoint y]	
]]]	

You can get the AST of this method with the following expression. 

[[[
(Point >> #<) ast
]]]

The root of the AST is a method node whose child is a return node. This return node has a message node and this message node has a receiver (the AST of the expression ==x < aPoint x==), a selector (==and:==) and a block node as argument. Explore this AST to get familiar with its structure. You can also inspect the ASTs of other methods of the system.

!!Basic Knowledge on ProgramNode and its Subclasses

Different kinds of nodes correspond to different classes. These classes form a hierarchy whose root is ==RBProgramNode==. This class implements several useful methods like: parent, nodesDo:, isVariable.... Browse it and its subclasses to understand the structure of Smalltalk ASTs.

!!Unification
The pattern matching algorithm in the AST rewriter is accomplished by a unification algorithm. This algorithm takes as input a tree (to search) and a pattern. A pattern is an enhanced AST that contains special nodes. These nodes abstract over some expressions and are called meta-variables (to avoid confusion with the Smalltalk variables). For example, a meta-variable can be used to match a variable while another can be used to match messages. 

The output of the algorithm is either false (there is no match found) or true. If it is true, that means that at least one match has been found. A match is a mapping from meta-variable to AST nodes. These mappings correspond to the values the meta-variables of the pattern should take for the pattern to be equal to the input tree. 

Lets look at a few examples. If X and Y denote meta-variables, the pattern ==self X== matches ==self open== if the meta-variable X is equals to 'open'. ==X Y== matches ==self open== if X equals 'self' and Y equals 'foo'. As a failing example, ==X X== doesn't match ==self open==.

!! Pattern syntax

To express patterns, the rewriter uses a special syntax that extends the standard Smalltalk one with meta-variables. There is several kinds of meta-variables depending on what nodes you want to match. They all start with a backquote.

==`node== This is the most basic meta-variable. It match any node.

==`@nodes== To match a list of nodes (like message args or temps).

==`#lit== To match literals.

==`[ ... ]== To match block.

==`.stmt== To match statements.

==`@.stmts== To match a list of statements.

==`{ :node | ... }== To match the nodes that satisfy the enclosed Smalltalk code.


!!Getting Started

[[[
| className realClass replacer category |
className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.
]]]

If you really just want the string 'tabs', the string 'tabs' with the
quotes is the search expression.

If you want to find it as part of a substring use something along:
[[[
   `#string `{ :node | node value isString and: [ node value
includesSubString: 'tabs' ] }
]]]

The ==`#string== is a literal pattern (booleans, characters, arrays,
strings, numbers, ...) and `{ ... adds a constraint on the preceeding
match.


[[[| className realClass replacer category |

className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.

replacer := RBParseTreeRewriter new
				replace: '`receiver oldMessage' with: '`receiver newMessage';
				yourself.
(realClass organization listAtCategoryNamed: category)
	collect: [:sel |
		| parseTree |
		parseTree := ( realClass >> sel) parseTree.
		(replacer executeTree: parseTree)
			ifTrue: [ realClass compile: replacer tree newSource " [1] " ] ]
]]]


!!Junk

!!!Identification de code avec RewriteTool

RewriteTool est un outil de récriture de code basé sur la définition
de reconnaissance de formes (pattern matching), appliquée sur des
arbres de syntaxes abstraites. Une documentation plus complète est
disponible à  http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/
Rewrite.html.

Il semble que Squeak ne dispose pas actuellement d'interface graphique
pour la récriture du code, mais uniquement pour identifier des
morceaux de code.


Cet outil de récriture de code est particulièrement utile lorsqu'on
doit transformer d'une manière répétitive du code. On peut représenter
dans les schémas (patterns) de reconnaissance des variables, des
listes, des instructions récursives et des littéraux.


- Variable. Un schéma peut contenir des variables en utilisant
  le backquote ou accent grave. Ainsi, ==`key== représente n'importe
  quelle variable, mais pas une expression.
- Liste. Pour représenter une expression potentiellement
  complexe, on utilise ==@== qui caractérise une liste. Ainsi, `@key
  peut représenter aussi bien une variable simple comme temp qu'une
  expression comme ==(aDict at: self keyForDict)==. Par exemple, | `@Temps
  | reconnaît une liste de variables temporaires. Le point . reconnaît
  une instruction dans une séquence de code.==`@.Statements==
  reconnaît une liste d'instructions. Par exemple, foo `@message:
  ==`@args== reconnaît n'importe quel message envoyé à  foo.
- Récursion. Pour que la reconnaissance s'effectue aussi à 
  l'intérieur de l'expression, il faut doubler la quote. La seconde
  quote représente la récursion du schéma cherché. Ainsi,
  ==``@object foo== reconnaît foo, à  quelque objet qu'il soit envoyé,
  mais observe également pour chaque reconnaissance si une
  reconnaissance est possible dans la partie représentée par la
  variable ==``@object==.
-	Littéraux. ==#== représente les littéraux. ainsi, ==`#literal==
  reconnaît n'importe quel littéral, par exemple 1, ==#()==, "unechaine"
  ou ==#unSymbol==.


!!!Des exemples d'identification de schémas

Si l'on veut identifier les expressions de type ==aDict at: aKey ifAbsent: aBlock== dans lesquelles les variables peuvent être des expressions composées, on écrit l'expression
suivante : ==``@aDict at: ``@aKey ifAbsent: ``@aBlock.==
Une telle expression identifie par exemple les expressions suivantes :

[[[
instVarMap at: aClass name ifAbsent: [oldClass instVarNames]
deepCopier references at: argumentTarget ifAbsent: [argumentTarget]
bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]
object at: (keyArray at: selectionIndex) ifAbsent: [nil]
]]]

Comme l'interface en Squeak ne permet pas encore de sélectionner les
classes sur lesquelles on veut travailler, le système analyse les 1
934 classes et quelque 42 869 méthodes qui sont disponibles dans la
distribution de base, ce qui peut sensiblement ralentir le traitement.

Voici quelques exemples d'
expressions qui pourraient être avantageusement transformées :

[[[
| `@Temps | ``@.Statements. ``@Boolean ifTrue: [^false]. ^true
| `@Temps | ``@.Statements. ^``@Boolean not
``@object not ifTrue: ``@block
``@object ifFalse: ``@block.
]]]

[[[
RBParseTreeRewriter new
 	replace: '``@aDictionary at: ``@key
 		ifAbsent:
 			[| `@Temps |
 			``@.Statements.
 			``@aDictionary at: ``@key put: ``@value]' with: '``@aDictionary at: ``@key
 		ifAbsentPut:
 			[| `@Temps |
 			``@.Statements.
 			``@value]';
	yourself
]]]

[[[
rule := RBUnderscoreAssignmentRule new.
environment := BrowserEnvironment new forPackageNames: #('PackageA'
'PackageB' ...).
SmalllintChecker runRule: rule onEnvironment: environment.
rule open
]]]

[[[
ORLintBrowser
	openRule: (RBCompositeLintRule rules: (RBCompositeLintRule
rulesGroupedFor: RBSpellingRule) name: 'Spelling')
	environment: (BrowserEnvironment new forPackageNames: #('Kernel'
'Collections-Abstract'))
]]]