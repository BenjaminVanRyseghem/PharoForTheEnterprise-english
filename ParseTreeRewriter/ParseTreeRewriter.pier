!Checking and Transforming Programs with Rewrite Engine


Manipulating programs automatically is a really powerful tool. A refactoring tool is a typical example. Another example is a rule checking engine such as the one presented in Chapter XXX. 
In this Chapter we present the underlying engine, named ParseTreeRewriter on top of which the 
Pharo refactoring browser and Critics browser are built. The ParseTreeRewriter has been developed by J. Brant and D. Roberts.

This powerful engine allows you to define abstract expressions to match and transform code. The engine is based on an abstract syntax tree unification algorithm that matches meta-variable to abstract syntax tree nodes and let you manipulate such meta-variables. 
In this chapter, we will first present the notion of abstract syntax tree, then the syntax of the parse tree rewriter expressions with practical examples. We also present Flamel an advanced editor to help user to express matching expressions. 


%http://pharorwrules.wordpress.com/2013/08/06/just-want-to-match/



!!Basic Knowledge on AST and other concepts

An abstract syntax tree (AST in short) is a data structure that is semantically equivalent to some source code. While source code is just a string of characters, an AST is a tree whose nodes correspond to the syntactic constructs of the parsed language. In Pharo, an AST node can represent a message, a method, a variable, a block, an assignment, etc... Such a tree is much easier to process than a plain string. That is why this data structure is used by most tools that have to deal with code.

Let's met our first AST. Consider the following method. 

[[[
Point >> < aPoint 
	"Answer whether the receiver is above and to the left of aPoint."

	^x < aPoint x and: [y < aPoint y]	
]]]	

You can get the AST of this method with the following expression. 

[[[
(Point >> #<) ast
]]]

The root of the AST is a method node whose child is a return node. This return node has a message node and this message node has a receiver (the AST of the expression ==x < aPoint x==), a selector (==and:==) and a block node as argument. Explore this AST to get familiar with its structure. You can also inspect the ASTs of other methods of the system.


+An inspector on an AST >file://figures/ASTInspector.pdf|width=50|label=astinspector+


Sending the message body ==body== to the ast returns the body of the method (as shown in Figure *astinspector* and ==selector== the method selector. 

[[[
(Point >> #<) ast body 
]]]

For example the AST of the following method is displayed in Figure *methodnode*.

[[[
selector: arg1 and: arg2
		  | temp1 temp2 |
		  temp1 := OrderedCollection new.
		  temp2 := arg1, arg2.
		  ^ temp1 + temp2
]]]

+The AST of the method ==selector:and:== >file://figures/methodnode.png|width=50|label=methodnode+


!!!Basic Knowledge on ProgramNode and its Subclasses

Different kinds of nodes correspond to different classes. These classes form a hierarchy whose root is ==RBProgramNode==. This class implements several useful methods such as: ==parent==, ==nodesDo:==, ==isVariable==.... Browse it and its subclasses to discover the structure and the capabilities of Pharo ASTs. 
There is a visitor class that supports the walking through ASTs.

Here is a view on the ProgramNode hierarchy showing the classes and their instance variables. 
(Camille: showing instance variables is maybe not good since it is subject to change in the near future)

[[[
RBProgramNode #('parent' 'comments' 'properties')
	RBMethodNode ('scope' 'selector' 'selectorParts' 'body' 'source' 'arguments' 'pragmas' 'replacements' 'nodeReplacements' 'compilationContext')
	RBParseErrorNode ('token' 'errorMessage')
	RBPragmaNode ('selector' 'selectorParts' 'arguments' 'left' 'right')
	RBReturnNode ('return' 'value')
	RBSequenceNode ('leftBar' 'rightBar' 'statements' 'periods' 'temporaries')
	RBValueNode ('parentheses')
		RBArrayNode ('left' 'right' 'statements' 'periods')
		RBAssignmentNode ('variable' 'assignment' 'value')
		RBBlockNode ('left' 'right' 'colons' 'arguments' 'bar' 'body' 'scope')
		RBCascadeNode ('messages' 'semicolons')
		RBLiteralNode 
			RBLiteralArrayNode ('isByteArray' 'stop' 'contents' 'start')
			RBLiteralValueNode ('token')
		RBMessageNode ('receiver' 'selector' 'selectorParts' 'arguments')
			RBPatternMessageNode ('isList' 'isCascadeList')
		RBVariableNode ('token')
			RBArgumentNode 
			RBClassReference 
			RBSelfNode 
			RBSuperNode 
			RBTemporaryNode 
			RBThisContextNode 
]]]






!!Unification
The pattern matching algorithm in the engine rewriter is accomplished by a unification algorithm. This algorithm takes as input a pattern (that describes what we look for) and a tree (that could or not match the pattern). A pattern is a tree containing special nodes called meta-variables. A meta-variable is a variable whose value will be set by the unification algorithm. For example, a meta-variable can be used to match a variable while another can be used to match messages.

The output of the algorithm is either false (there is no match found) or true. If it is true, that means that at least one match has been found. A match is a mapping from meta-variable to AST nodes of the input tree. These mappings correspond to the values the meta-variables of the pattern should take for the pattern to be equal to the input tree. 

Let's look at a few examples. If X and Y denote meta-variables, the pattern ==self X== matches ==self open== with the mapping: X -> 'open'. The pattern ==X Y== matches ==self open== with the mapping: Y -> 'self', Y -> 'foo'. As a failing example, ==X X== doesn't match ==self open==.

!! Pattern syntax

To express patterns, the rewriter uses a special syntax that extends the standard Smalltalk syntax with meta-variables. There is several kinds of meta-variables depending on what nodes you want to match. They all start with a backquote. We will show some hands-on just after. 

- ==`node== This is the most basic meta-variable. It matches any node.

Examples:  

==`receiver foo== matches the following expressions:
[[[
self foo
x foo
OrderedCollection foo
]]]

==self `msg: `arg== matches any one-argument message sent to self:
[[[
self as: Array
self instVarAt: 2
]]]

- ==`@nodes== To match a list of zero or more nodes (like message args or temps). 

Examples:

==`@receiver foo== matches

[[[
self foo
self size foo
(self at: 1) foo
]]]

==self `@msg: `@args== matches any message sent to self:

[[[
self class
self at: 4
self perform: #at: with: 4
]]]

- ==`#literal== To match literals. 

==`#literal size== matches any message sent to a literal whose selector is size 

[[[
3 size
'foo' size
#(a b c) size
]]]

- ==``== supports recursive search. For example, ==``@receiver parent== matches
==x parent parent== twice:
-- the first time with the mapping: receiver -> x
-- the second time eith the mapping: receiver -> x parent


- ==`.stmts== To match statements. The pattern ==`.Sta1.== matches

[[[
x := 1.
]]]

Combined with ==@==, you can match e list of statements. 
The pattern ==`@.stmts== matches any list of statements.


- ==`{ :node | ... }== To match the nodes that satisfy the enclosed Smalltalk code. The pattern ==`{ :node | node isInstance }== matches instance variables.


!!!Examples


[[[
| methodNode searcher  |
methodNode := OpalCompiler new parse: 'test 
| x |
x := 1. 
y := 2.
z := (self at: #x) size.
x + y'.

searcher := RBParseTreeSearcher new.
searcher
	matches: 'self at: `#literal'
      do: [ :aNode :answer | answer add: aNode ].
searcher executeTree: methodNode initialAnswer: Set new.
searcher answer
]]]


[[[
| rbMethodNode |
rbMethodNode := OpalCompiler new parse: 'test 
| x |
x := 1. 
y := 2.
z := (self at: #x) size.
x + y'.

(RBParseTreeSearcher new
        matches: '`{:node | node isVariable }'
        do: [ :aNode :answer | answer add: aNode; yourself ] )
               executeTree: rbMethodNode initialAnswer: Set new.

]]]




self matcher
matches: '``@lotOfStuffBefore globals at: ``@lotOfStuffAfter'
do: [:theMatch :theOwner | theMatch inspect].

rule := SearchGlobalsAtUsage new.
environment := RBClassEnvironment class: Result.
RBSmalllintChecker runRule: rule onEnvironment: (environment)




[[[
| rbMethodNode |
rbMethodNode := OpalCompiler new parse: 'test 
| x |
x := 1. 
y := 2.
x + y'.

(RBParseTreeSearcher new
        matches: '`{:node | node isVariable }'
        do: [ :aNode :answer | answer add: aNode; yourself ] )
               executeTree: rbMethodNode initialAnswer: Set new.

]]]










[[[
| className realClass replacer category |
className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.
]]]

If you really just want the string 'tabs', the string 'tabs' with the
quotes is the search expression.

If you want to find it as part of a substring use something along:
[[[
   `#string `{ :node | node value isString and: [ node value
includesSubString: 'tabs' ] }
]]]

The ==`#string== is a literal pattern (booleans, characters, arrays,
strings, numbers, ...) and `{ ... adds a constraint on the preceeding
match.


[[[| className realClass replacer category |

className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.

replacer := RBParseTreeRewriter new
				replace: '`receiver oldMessage' with: '`receiver newMessage';
				yourself.
(realClass organization listAtCategoryNamed: category)
	collect: [:sel |
		| parseTree |
		parseTree := ( realClass >> sel) parseTree.
		(replacer executeTree: parseTree)
			ifTrue: [ realClass compile: replacer tree newSource " [1] " ] ]
]]]


























!!Junk

- Variable. Un schéma peut contenir des variables en utilisant
  le backquote ou accent grave. Ainsi, ==`key== représente n'importe
  quelle variable, mais pas une expression.

- Liste. Pour représenter une expression potentiellement
  complexe, on utilise ==@== qui caractérise une liste. Ainsi, `@key
  peut représenter aussi bien une variable simple comme temp qu'une
  expression comme ==(aDict at: self keyForDict)==. Par exemple, | `@Temps
  | reconnaît une liste de variables temporaires. Le point . reconnaît
  une instruction dans une séquence de code.==`@.Statements==
  reconnaît une liste d'instructions. Par exemple, foo `@message:
  ==`@args== reconnaît n'importe quel message envoyé à  foo.

- Récursion. Pour que la reconnaissance s'effectue aussi à 
  l'intérieur de l'expression, il faut doubler la quote. La seconde
  quote représente la récursion du schéma cherché. Ainsi,
  ==``@object foo== reconnaît foo, à  quelque objet qu'il soit envoyé,
  mais observe également pour chaque reconnaissance si une
  reconnaissance est possible dans la partie représentée par la
  variable ==``@object==.

-	Littéraux. ==#== représente les littéraux. ainsi, ==`#literal==
  reconnaît n'importe quel littéral, par exemple 1, ==#()==, "unechaine"
  ou ==#unSymbol==.


!!!Des exemples d'identification de schémas

Si l'on veut identifier les expressions de type ==aDict at: aKey ifAbsent: aBlock== dans lesquelles les variables peuvent être des expressions composées, on écrit l'expression
suivante : ==``@aDict at: ``@aKey ifAbsent: ``@aBlock.==
Une telle expression identifie par exemple les expressions suivantes :

[[[
instVarMap at: aClass name ifAbsent: [oldClass instVarNames]
deepCopier references at: argumentTarget ifAbsent: [argumentTarget]
bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]
object at: (keyArray at: selectionIndex) ifAbsent: [nil]
]]]

Comme l'interface en Squeak ne permet pas encore de sélectionner les
classes sur lesquelles on veut travailler, le système analyse les 1
934 classes et quelque 42 869 méthodes qui sont disponibles dans la
distribution de base, ce qui peut sensiblement ralentir le traitement.

Voici quelques exemples d'
expressions qui pourraient être avantageusement transformées :

[[[
| `@Temps | ``@.Statements. ``@Boolean ifTrue: [^false]. ^true
| `@Temps | ``@.Statements. ^``@Boolean not
``@object not ifTrue: ``@block
``@object ifFalse: ``@block.
]]]

[[[
RBParseTreeRewriter new
 	replace: '``@aDictionary at: ``@key
 		ifAbsent:
 			[| `@Temps |
 			``@.Statements.
 			``@aDictionary at: ``@key put: ``@value]' with: '``@aDictionary at: ``@key
 		ifAbsentPut:
 			[| `@Temps |
 			``@.Statements.
 			``@value]';
	yourself
]]]

[[[
rule := RBUnderscoreAssignmentRule new.
environment := BrowserEnvironment new forPackageNames: #('PackageA'
'PackageB' ...).
SmalllintChecker runRule: rule onEnvironment: environment.
rule open
]]]

[[[
ORLintBrowser
	openRule: (RBCompositeLintRule rules: (RBCompositeLintRule
rulesGroupedFor: RBSpellingRule) name: 'Spelling')
	environment: (BrowserEnvironment new forPackageNames: #('Kernel'
'Collections-Abstract'))
]]]
