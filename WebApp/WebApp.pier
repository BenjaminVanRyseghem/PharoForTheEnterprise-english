!Building and deploying your first web app with Pharo

-First version: July 10, 2012 by Sven Van Caekenberghe
-Second version: September 10, 2012 by StÃ©phane Ducasse

There are lots of ways to get something on the Web today. However, it remains important that you understand the actual mechanics of building and deploying a web application. This guide explains how to build and deploy your first web application using Pharo.
Of course, there are an infinite number of ways to make a web app. Even in Pharo, there are multiple frameworks approaching this problem, most notably Seaside, AIDAweb and Iliad. Here, we'll be using the foundational framework called Zinc HTTP Components. By doing so, we'll be touching the fundamentals of HTTP and web apps.

This chapter could have been called ''understanding HTTP fundamentals through Zinc HTTP Components''.

Using nice objects, abstracting each concept in HTTP and related open standards, the actual code will be easier than you might expect.
The dynamic, interactive nature of Pharo combined with its rich IDE and library will allow us to do things that are nearly impossible using other technology stacks. By chronologically following the development process, you will see the app growing from something trivial to the final result. Finally, we will save our source code in a repository and deploy for real in the cloud.

Let's get started.



!! The Web App

The web application that we are going to build will show a picture and allow users to change the picture by uploading a new one as shown by Figure *imageweb*. Because we want to focus on the basic mechanics, the fundamentals as well as the build and deploy process, there are some simplifications. There will be one picture for all users, no login and we will store the picture in memory.

+A simple web application>file://figures/image-web-app.png|width=80|label=imageweb+

In our implementation, ==/image== will serve an HTML page containing the image and a form. To serve the raw image itself, we'll add a parameter, like ==/image?raw=true==. These will be GET HTTP requests. The form will submit its data to ==/image== as a POST request.


!! Downloading Pharo

Go to http://www.pharo.org and download the whole self-contained package for your platform, it is just 12 to 14 MB. Select the released version 2.0. Although not recommended for beginners, current development version 3.0 will do just fine as well. Double-click and you enter the Pharo world.

+Pharo>file://figures/pharo-in-action.png|width=80|label=pharo-in-action+


Pharo is an incredible sophisticated and deep environment and toolset. The Pharo by Example book available at: http://www.pharobyexample.org is probably the best way to get started if all this is totally new to you. In what follows we assume you at least read the first chapter, 'A Quick Tour of Pharo'.

!! Running an HTTP server

Open a Workspace, type and execute
[[[
ZnServer startDefaultOn: 8080.
]]]

Now open the address ==http://localhost:8080== in your favorite browser. You should get the default welcome page of Zinc HTTP Components. If you visit ==http://localhost:8080/help== you will see a list of all available pages. Now add the following line to your workspace and execute it:

[[[
ZnServer default logToTranscript.
]]]

Next open the Transcript and visit or reload a page. You should see log output like this

[[[
2013>07>07 00:22:49 479147 D Executing request/response loop 
2013>07>07 00:22:49 479147 I Read a ZnRequest(GET /) 
2013>07>07 00:22:49 479147 T GET / 200 977B 2ms 
2013>07>07 00:22:49 479147 I Wrote a ZnResponse(200 OK text/html;charset=utf>8 977B)
]]]

You can see the server entering the request/response loop for a certain connection/thread. A request is read and a response is written. Let's have a look under the hood. Put the server in debug mode and inspect it like this

[[[
ZnServer default debugMode: true; inspect.
]]]

Visit and reload a page. Now you can use the inspector to explore the actual lastRequest and lastResponse objects. Pretty cool, right?

Tomplete our little tour, let's try one more thing. We can execute any request programmatically as well, using an HTTP client. To visit a page, try inspecting the result of the following expression:

[[[
ZnClient new get:'http://localhost:8080/random'
]]]

If you would look inside the client object, you would find similar request and response objects - this makes total sense since the client talks to the server and vice versa, over the network. If you want, you can stop the server executing the following expression: 

[[[
ZnServer stopDefault.
]]]

If you are curious, please consult the Zinc HTTP Components documentation available at: @@ http @@



!! Saying hello world

Let's lay the groundwork for our new web application by making a version that only says 'Hello World!'. We'll be extending the web app gradually until we reach our functional goal.

Open the Nautilus System Browser and create a new package (right click in the first column) called something like "'MyFirstWebApp'". Now create a new class (right click in the second column) with the same name, "MyFirstWebApp". You will be given a template: edit 'NameOfSubclass' and accept by clicking 'OK'. Your definition should now appear in the bottom pane.

[[[
Object subclass: #MyFirstWebApp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MyFirstWebApp'
]]]

Any object can be a web app, it only has to respond to a message called ==handleRequest:== to answer a response based on a request. Now add the following method

[[[
MyFirstWebApp>>handleRequest: request
	request uri path = #image
		ifFalse: [ ^ ZnResponse notFound: request uri ].
	^ ZnResponse ok: (ZnEntity text: 'Hello World!')
]]]

Create a new protocol called 'public' (by right-clicking in the third column). When the new protocol is selected, a new method template will appear in the bottom pane. Overwrite the whole template with the code above and accept it.

+Defining the >file://figures/pharo-in-action.png|width=80|label=pharo-in-action+

What we do here is look at the incoming request to make sure the URI path is ==/image== which will be the final name of our web app. If not, we return a Not Found (code 404) response. If so, we create and return an OK response (code 200) with a simple text entity as body or payload.

[[[
MyFirstWebApp>>value: request
	^ self handleRequest: request
]]]

Now do the same for the #value: method, effectively making it an alias of ==handleRequest:== - this is needed so our web app object can be used more flexibly. To test our web app, we'll add it as one of the pages of the default server, like this

[[[
ZnServer startDefaultOn: 8080.
ZnServer default delegate map: #image to: MyFirstWebApp new.
]]]



% Local Variables:
% eval: (flyspell-mode -1)
% End:
