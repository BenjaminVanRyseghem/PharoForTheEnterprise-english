!Building a Simple Calculator with Spec

!!Introduction
In this chapter we will develop a simple calculator to get started with Spec. Our focus will be on building the GUI to come up with a simple but good-looking calculator.
After designing the GUI we will move on to render this nice, but hollow interface operational (let's say we will focus first on the VC part of MVC, and later on the M).

In order to construct our GUI we need to know what Spec expects to find in the class we will be creating. There are certain selectors and method that have to be present at instance and class side and that will be used by Spec when we do Specalc new openWithSpec.
Basically, at the instance side of the class we will define the widgets that we will be using, some aspects of these widgets like labels, actions, states, and the behaviour these widgets will have. On the other hand, at class side we will set up the basic design of our GUI -how the widgets are laid out- and its tittle.

Summarising:
instance side -> widget instantiation and format, along with actions performed by these.
class side -> the composed layout. How all our widgets will be laid out in a window.
So let us start by analysing the widgets we will be using.

!! The widgets
In this simple calculator we will need buttons to represent the 0 to 9 digits, some basic arithmetic operations, the dot to use floating numbers, a clear screen button, the = button to get the result, and some others like changing the sign, square rooting, etc. Also, we will need a display to see the numbers entered and get the result. 

But first things first. We have to create the class from which our calculator will be instantiated; we are going to use a composed layout model for our class, therefore our class will be a subclass of #ComposableModel.
So open the browser and create a new package called Specalc, enter the following class definition and accept it. Don't worry, for now, about the instanceVariableNames we will get to that part soon.
!!! Defining the class Specalc
[[[
ComposableModel subclass: #Specalc
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Specalc'
]]]

Remember that we mentioned that when an instance of our calculator is openWithSpec, Spec will send a message to some selectors that expect to find in our class -both at class and instance side-.
Our starting point will be implementing the method that will respond to the initializeWidgets selector. We want to have 10 buttons for the digits (0 to 9), a plus button, a minus button, a multiplication button, a division button, a change sign button, a clear display button, a dot button for entering float-numbers, an equal button, and a square root button, and a log button. That is a total of 20 buttons. In addition, we will need the display. 
This method can grow considerably depending on the number of widgets you might need. Therefore, it is sometimes convenient to break it down into simpler methods. 
Here is our first draft of the initializeWidgets method:
!!! A draft of our initializeWidgets method
[[[
Specalc>>initializeWidgets 
	"instantiate the digit buttons"
	button0 := self newButton.
	button1 := self newButton.
	button2 := self newButton.
	button3 := self newButton.
	button4 := self newButton.
	button5 := self newButton.
	button6 := self newButton.
	button7 := self newButton.
	button8 := self newButton.
	button9 := self newButton.
	"instantiate the basic arithmetic buttons"
	buttonPlus	:= self newButton.
	buttonMinus := self	newButton.
	buttonMult	:= self newButton.
	buttonDiv	:= self newButton.
	buttonEq	:= self newButton.
	"instantiate the remaining buttons"
	buttonDot	 := self newButton.
	buttonSqr	 := self newButton.
	buttonLog	 := self newButton.
	buttonChange := self newButton.
	buttonClear	 := self newButton.
	"instantiate the display"
	display		:=	self newLabel.
	"send a message to format some aspects of the buttons"
	self formatDigitButtons.
	self formatOtherButtons
]]]

If the GUI you are building has only a limited number of widgets, you might even want to send some messages to the newly instantiated objects to set some of their attributes. In our case, as we said before, we are going to leave that to another method to avoid excessive cluttering.
So let us break down this method into more convenient and uncluttered ones.
!!! A cleaner version of the method
[[[
Specalc>>initializeWidgets 
	"instantiate the digit buttons"
	self initializeDigitButtons.
	"instantiate the basic arithmetic buttonsand the remaining buttons"
	self initializeOtherButtons.
	"instantiate the display"
	display	:=	self newLabel
]]]
Upon accepting, you will be prompted whether initializeDigitButtons and, initializeOtherButtons are typos or are methods to be coded later. Of course, it is not a typo these methods have not been defined yet. The same will happen to the instance variable display, so select declare as new instance variable. 

Then we define the other methods:
!!! The initializeDigitButtons method
[[[
Specalc>>initializeDigitButtons
"instantiate the digit buttons"
button0 := self newButton.
button1 := self newButton.
button2 := self newButton.
button3 := self newButton.
button4 := self newButton.
button5 := self newButton.
button6 := self newButton.
button7 := self newButton.
button8 := self newButton.
button9 := self newButton.

self formatDigitButtons
]]]
The same happens here, accept all buttonX as instance variables and formatDigitButtons as a method.
!!! The initializeDigitButtons method
[[[
Specalc>>initializeOtherButtons
	"instantiate the basic arithmetic buttons"
	buttonPlus	:= self newButton.
	buttonMinus := self	newButton.
	buttonMult	:= self newButton.
	buttonDiv	:= self newButton.
	buttonEq	:= self newButton.
	"instantiate the remaining buttons"
	buttonDot	 := self newButton.
	buttonSqr	 := self newButton.
	buttonLog	 := self newButton.
	buttonChange := self newButton.
	buttonClear	 := self newButton.
	
	self formatOtherButtons
]]]

Finally, we add one last initialisation method and categorise all these methods in the initialize protocol.
!!! The usual initialize method
[[[
Specalc>>initialize

	super initialize
]]]
You should see all our initializers like in the Figure *figClass01*.

+Initialization methods of our calculator>file://figures/figClass01.png|width=90|label=figClass01+

!! Formating the widgets
Next, we will have to define the methods that we previously accepted Specalc>>formatDigitButtons and Specalc>>formatOtherButtons. These methods will send messages to the instances of buttons and label we have just instantiated telling them what to show, what to perform, etc.
!!! Formating the Digit buttons
[[[
Specalc>>formatDigitButtons

	button0
		label: '0';
		action: [ display label: ((display label,'0') asNumber) asString];
		state: true.
		
	button1
		label: '1';
		action:  [ display label: ((display label,'1') asNumber) asString ];
		state: true.
		
	button2
		label: '2';
		action: [ display label: ((display label,'2') asNumber) asString ];
		state: true.
		
	button3
		label: '3';
		action: [ display label: ((display label,'3') asNumber) asString ];
		state: true.
		
	button4
		label: '4';
		action: [ display label: ((display label,'4') asNumber) asString ];
		state: true.
		
	button5
		label: '5';
		action: [ display label: ((display label,'5') asNumber) asString ];
		state: true.

	button6
		label: '6';
		action: [ display label: ((display label,'6') asNumber) asString ];
		state: true.
		
	button7
		label: '7';
		action:[ display label: ((display label,'7') asNumber) asString ];
		state: true.

	button8
		label: '8';
		action: [ display label: ((display label,'8') asNumber) asString ];
		state: true.
		
	button9
		label: '9';
		action: [ display label: ((display label,'9') asNumber) asString ];
		state: true
]]]

This is a long method, but it's very simple to dissect because once we have grasped the first button, the rest is similar.
So here is what each of these lines do. First we have the object instantiated in the previous methods, that's buttonX, if you follow the syntax of one of this it's a cascade of messages sent to the object.
First we tell buttonX to display some label, using the label: selector with a string as argument. In the case of button1 label:'1' will obviously make the button show the digit 1 as label. Next is another selector; action: followed by a block.

Let's analyse what this block does. Recall that we instantiated a display object from Spec's LabelModel class which is actually the screen of our calculator.
Following the precedence of messages the first evaluated expression is:
(display label,'9')
We are sending a message to our display to retrieve the contents of it and concatenate the string '9'. Why? Basically because our display object might content some string of numbers previously entered and we want to put the newly pressed number behind of what's already on the screen. Then you noticed that we send the message asNumber, the purpose of doing this is to avoid entering zeros that are not significant. When we convert our string to a number the non-relevant zeros are discarded otherwise we will have a calculator that will show awkward numbers like 000234, when only 234 should be displayed. Finally we convert that back to a string and pass this as an argument to the label: selector of our display. The result is that the display now contains what was previously there plus the content of our recently push button.
The last message we send is state: which accepts as an argument a boolean value. We set it to 'true' to avoid having to double click on each button to have a value entered on the display. You will notice when buttons are active because they show a pale blue shadowing. Try setting the state to 'false' and you will see what annoying is to have to press two times each button.
A comment on style is appropriate here. The exposed method could have been written in a much more elegant and simple way, making the digit button object pass it's label instead of hard-coding the string '1' or '2', etc. However, I choose not to do it that way to keep it more easy to understand and follow.





!! Conclusion

This chapter illustrates how to use Spec to build applications. A deeper explanation of Spec will be available in a companion chapter.



% Local Variables:
% eval: (flyspell-mode -1)
% End:
