! Zinc

HTTP is arguably the most important application level network protocol for what we consider to be the internet. It is the protocol that allows web browsers and web servers to communicate. It is also becoming the most popular protocol for implementing web services.

Naturally, Pharo Smalltalk has out of the box support for HTTP.

!! An introduction to HTTP

HTTP, short for Hypertext Transfer Protocol, functions as a request-response protocol in the client-server computing model. As an application level protocol it is layered on top of a reliable transport such as a TCP socket stream. The most important standard specification document describing HTTP version 1.1 is RFC 2616. As usual another good starting point is the Wikipedia article on HTTP.

[[[
    +------>> request >>------+
[client]                   [server]
    +------<< response <<-----+
]]]

A client, often called user-agent, submits an HTTP request to a server which will respond with an HTTP response. The initiative of the communication lies with the client. Requests and responses are quite similar and are often called HTTP messages.

In HTTP parlance, you request a resource. A resource, sometimes called an entity, is the combination of a collection of bytes and a mime-type. A simple text resource will consist of bytes encoding the string in some encoding, for example UTF–8, and the mime-type ‘text/plain;charset=utf–8’. An HTML resource will have a mime-type like ‘text/html;charset=utf–8’.

To specify which resource you want, a URL (Uniform Resource Locator) is used. Web addresses are the most common form of URL. For example, http://www.pharo-project.org/images/pharo.png, is a URL that referes to a PNG image resource on a specific server.

The reliable transport connection between an HTTP client and server is used bidirectionally: both to send the request as well as to receive the response. It can be used for just one request/response cycle, as was the case for HTTP version 1.0, or it can be reused for multiple request/response cycles, as is the default for HTTP version 1.1.

!! Zinc HTTP Components

Zinc HTTP Components is an open source Smalltalk framework to deal with HTTP. It models most concepts of HTTP and its related standards and offers both client and server functionality. One of its key goals is to offer understandability (Smalltalk’s design principle number one). Anyone with a basic understanding of Smalltalk and the HTTP principles should be able to understand what is going on and learn, by looking at the implementation. Zinc, or Zn, after its namespace prefix, is an integral part of Pharo Smalltalk since version 1.3. It has been ported to other Smalltalk implementations such as Squeak and Gemstone.

The reference Zn implementation lives in several places:

- http://www.squeaksource.com/ZincHTTPComponents
- http://mc.stfx.eu/ZincHTTPComponents
- https://www.github.com/svenvc/zinc

Installation or updating instructions can be found there.

!! Doing a simple request

The key object to programmatically execute HTTP requests is called ZnClient. You instantiate it, use its rich API to configure and execute an HTTP request and access the response. ZnClient is a stateful object to be treated like a builder. Let’s get started with the simplest possible usage.

[[[
ZnClient new get: 'http://zn.stfx.eu/zn/small.html'.
]]]

Select the above expression and inspect or print it. If all goes well, you’ll get a String back containing a very small HTML document. The #get: method belongs to the convenience API. Let’s be a bit more explicit about what happened.

[[[
ZnClient new
  url: 'http://zn.stfx.eu/zn/small.html';
  get;
  response.
]]]

Here we explicitly set the url using #url:, execute an HTTP GET using #get and ask for the response object using #response.
The above returns a ZnResponse object. It consists of 3 elements:

# a ZnStatusLine object
# a ZnHeaders object
# an optional ZnEntity object

The status line says HTTP/1.1 200 OK, which means the request was successful. This can be tested by sending #isSuccess to either the response object or the client itself. The headers contain meta data related to the response, including:

- the content-type (a mime-type), accessed with #contentType
- the content-length (a byte count), accessed with #contentLength
- the date the response was generated
- the server that generated the response

The entity is the actual resource: the bytes that should be interpreted in the context of the content-type mime-type. Zn will automatically convert non-binary mime-types into Strings using the correct encoding. In our example, the entity will be an instance of ZnStringEntity, a concrete subclass of ZnEntity.

Like any Smalltalk object, you can inspect or explore the ZnResponse object. You might be wondering how this response was actually transferred over the network. That is easy with Zn, as the key HTTP objects all implement #writeOn: for this purpose.

[[[
| response |
response := (ZnClient new)
  url: 'http://zn.stfx.eu/zn/small.html';
  get;
  response.
response writeOn: Transcript.
Transcript flush.
]]]

If you have the Transcript open, you should see something like the following:

[[[
HTTP/1.1 200 OK
Date: Tue, 08 May 2012 19:00:25 GMT
Modification-Date: Thu, 10 Feb 2011 08:32:30 GMT
Content-Length: 113
Server: Zinc HTTP Components 1.0
Vary: Accept-Encoding
Content-Type: text/html;charset=utf-8

<html>
<head><title>Small</title></head>
<body><h1>Small</h1><p>This is a small HTML document</p></body>
</html>
]]]

The first CRLF terminated line is the status line. Next are the headers, each on a line with a key and a value. An empty line ends the headers. Finally, the entity bytes follows, either up to the content length or up to the end of the stream.

You might wonder what the request looked like as it went over the line ? You can find out using the same technique.

[[[
| request |
request := (ZnClient new)
  url: 'http://zn.stfx.eu/zn/small.html';
  get;
  request.
request writeOn: Transcript.
Transcript flush.
]]]

In an open Transcript you will now see:

[[[
GET /zn/small.html HTTP/1.1
Accept: */*
User-Agent: Zinc HTTP Components 1.0
Host: zn.stfx.eu
]]]

A ZnRequest object consists of 3 elements:

# a ZnRequestLine object
# a ZnHeaders object
# an optional ZnEntity object

The request line contains the HTTP method (sometimes called verb), URL and the HTTP protocol version. Next come the request headers, similar to the response headers, meta data including:

- the host we want to talk to
- the kind of mime-types that we accept or prefer
- the user-agent that we are

If you look carefully at the Transcript you will see the empty line terminating the headers. For most kinds of requests, like for a GET, there is no entity.

For debugging and for learning, it can be helpful to enable logging on the client. Try the following.

[[[
ZnClient new
  logToTranscript;
  get: 'http://zn.stfx.eu/zn/small.html'.
]]]

This will print out lots of information on the Transcript, except for the entity (resource) itself because that might be too large.

[[[
2012-05-09 14:30:59 866904 I Wrote a ZnRequest(GET /zn/small.html)
2012-05-09 14:30:59 866904 D Sent headers
Accept: */*
User-Agent: Zinc HTTP Components 1.0
Host: zn.stfx.eu

2012-05-09 14:30:59 866904 I Read a ZnResponse(200 OK text/html;charset=utf-8 113B)
2012-05-09 14:30:59 866904 D Received headers
Date: Wed, 09 May 2012 12:25:44 GMT
Modification-Date: Thu, 10 Feb 2011 08:32:30 GMT
Content-Length: 113
Server: Zinc HTTP Components 1.0
Vary: Accept-Encoding
Content-Type: text/html;charset=utf-8

2012-05-09 14:30:59 866904 T GET /zn/small.html 200 113B 171ms
]]]

In a later subsection about server logging, which uses the same mechanism, you will learn how to interpret and customize logging.

!! HTTP Success ?

A simple view of HTTP is: you request a resource and get a response back containing the resource. But even if the mechanics of HTTP did work, and even that is not guaranteed (see the next section), the response could not be what you expected.

HTTP defines a whole set of so called status codes to define various situations. These codes turn up as part of the status line of a response. The dictionary mapping numeric codes to their textual reason string is predefined.

[[[
ZnConstants httpStatusCodes.
]]]

A good overview can be found in the Wikipedia article List of HTTP status codes. The most common code, the one that indicates success is numeric code 200 with reason ‘OK’. Have a look at the testing protocol of ZnResponse for how to interpret some of them.

So if you do an HTTP request and get something back, you cannot just assume that all is well. You first have to make sure that the call itself (more specifically the response) was successful. As mentioned before, you can do so by sending #isSuccess to the response or the client.

[[[
| client |
client := ZnClient new.
client get: 'http://zn.stfx.eu/zn/numbers.txt'.
client isSuccess
  ifTrue: [ client contents lines collect: [ :each | each asNumber ] ]
  ifFalse: [ self inform: 'Something went wrong' ]
]]]

To make it easier to write better HTTP client code, ZnClient offers some useful API. You can ask the client to consider non-successful HTTP responses as errors with the #enforceHTTPSuccess option. The client will then automatically throw a ZnHTTPUnsuccesful exception. This is generally useful when upstream code handles errors.

To install a local failure handler, there is the #ifFail: option. This will invoke a block, optionally passing an exception, whenever something goes wrong. Together, this allows the above code to be rewritten as follows.

[[[
ZnClient new
  enforceHttpSuccess: true;
  ifFail: [ :exception |
              self inform: 'Cannot get numbers: ', exception printString ];
  get: 'http://zn.stfx.eu/zn/numbers.txt'.
]]]

Maybe it doesn’t look like a big difference, but combined with some other options and features of ZnClient that we’ll see later on, code does become more elegant and more reliable at the same time.

!! Dealing with networking reality

As a network protocol, HTTP is much more complicated than an ordinary message send. The famous Fallacies of Distributed Computing eloquently list the issues involved:

- The network is reliable.
- Latency is zero.
- Bandwidth is infinite.
- The network is secure.
- Topology doesn’t change.
- There is one administrator.
- Transport cost is zero.
- The network is homogeneous.

Zn will signal various exceptions when things go wrong, at different levels. ZnClient and the underlying framework have constants, settings and options to deal with various aspects related to these issues.

Doing an HTTP request-response cycle can take an unpredictable amount of time. Client code has to specify a timeout, the maximum amount of time we are prepared to wait for a response, and be prepared for when that timeout is exceeded. The fact you don’t get an answer within a specified timeout can mean that some networking component is extremely slow, but it could also mean that the server simply refuses to answer.

Setting the timeout directly on a ZnClient is the easiest.

[[[
ZnClient new
  timeout: 1;
  get: 'http://zn.stfx.eu/zn/small.html'.
]]]

The timeout counts for each socket level connect, read and write operation, separately. You can dynamically redefine the timeout using the ZnConnectionTimeout DynamicVariable.

[[[
ZnConnectionTimeout
  value: 5
  during: [ ^ ZnClient new get: 'http://zn.stfx.eu/zn/small.html' ].
]]]

Zn defines its global default timeout in seconds as a setting.

[[[
ZnNetworkingUtils defaultSocketStreamTimeout.
ZnNetworkingUtils defaultSocketStreamTimeout: 60.
]]]

This setting affects most framework level operations, if nothing else is specified.

During the execution of HTTP, various network exceptions, as subclasses of NetworkError, might be thrown. These will all be caught by the #ifFail: block when installed.

To deal with temporary or intermittent network or server problems, ZnClient offers a retry protocol. You can set how many times a request should be retried and how many seconds to wait between retries.

[[[
ZnClient new
  numberOfRetries: 3;
  retryDelay: 2;
  get: 'http://zn.stfx.eu/zn/small.html'.
]]]

In the above example, the request will be tried up to 3 times, with a 2 second delay between attempts. Note that the definition of failure/success is broad: it includes for example the option to enforce HTTP success.

!! Building URL’s

Zn uses ZnUrl objects to deal with URLs. ZnClient also contains API to build URLs. Let us revisit our initial example, using explicit URL construction with the ZnClient API.

[[[
ZnClient new
  http;
  host: 'zn.stfx.eu';
  addPath: 'zn';
  addPath: 'small.html';
  get.
]]]

Instead of giving a string argument to be parsed into a ZnUrl, we now provide the necessary elements to construct the URL manually, by sending messages to our ZnClient object. With #http we set what is called the scheme. Then we set the hostname. Since we don’t specify a port, the default port for HTTP will be used, port 80. Next we add path elements, extending the path one by one.

A URL can also contain query parameters. Let’s do a Google search.

[[[
ZnClient new
  http;
  host: 'www.google.com';
  addPath: 'search';
  queryAt: 'q' put: 'Pharo Smalltalk';
  get.
]]]

Query parameters have a name and a value. Certain special characters have to be encoded. You can build the same URL with the ZnUrl object, in several ways.

[[[
ZnUrl new
  scheme: #http;
  host: 'www.google.com';
  port: 80;
  addPathSegment: 'search';
  queryAt: 'q' put: 'Pharo Smalltalk';
  yourself.
]]]

The printable representation of the URL is

[[[
http://www.google.com/search?q=Pharo%20Smalltalk
]]]

This can easily be parsed again into a ZnUrl object

[[[
'http://www.google.com/search?q=Pharo%20Smalltalk' asZnUrl.
'http://www.google.com:80/search?q=Pharo Smalltalk' asZnUrl.
]]]

Note how the ZnUrl parser is forgiving with respect to the space, like most browser would do. When producing an external representation, proper encoding will take place. Please consult the class comment of ZnUrl for a more detailed look at the capabilities of ZnUrl as a standalone object.

!! ZnClient lifecycle

HTTP 1.1 defaults to keeping the client connection to a server open, and the server will do the same. This is useful and faster if you to issue more than one request. ZnClient implements this behavior by default.

[[[
Array streamContents: [ :stream | | client |
  client := ZnClient new url: 'http://zn.stfx.eu'.
  (1 to: 10) collect: [ :each | | url |
    url := '/random/', each asString.
    stream nextPut: (client path: url; get) ].
  client close ].
]]]

The above example sets up a client to connect to a specific host. Then it collects the results of 10 different requests, asking for random strings of a specific size. All request will go over the same network connection.

Neither party is required to keep the connection open for a long time, as this consumes resources. Both parties should be prepared to deal with connections closing, this is not an error. ZnClient will try to reuse an existing connection and reconnect once if this reuse fails. The option connectionReuseTimeout limits how old a connection can be for reuse to be attempted.

Note how we also close the client. A network connection is an external resource, like a file, that should be properly closed after use. If you don’t do that, they will get cleaned up eventually by the system, but it is more efficient to do it yourself.

In many situations, you only want to do one single request. HTTP 1.1 has provisions for this situation. The beOneShot option of ZnClient will do just that.

[[[
ZnClient new
  beOneShot;
  get: 'http://zn.stfx.eu/numbers.txt'.
]]]

With the beOneShot option, the client notifies the server that it will do just one request and both parties will consequently close the connection after use, automatically. An explicit close of the ZnClient object it no longer needed.

!! Basic Authentication

There are various techniques to add authentication, a mechanism to control who accesses which resources, to HTTP. This is orthogonal to HTTP itself. The simplest and most common form of authentication is called ‘Basic Authentication’.

[[[
ZnClient new
  username: 'john@hacker.com' password: 'trustno1';
  get: 'http://www.example.com/secret.txt'.
]]]

That is all there is to it. If you want to understand how this works, look at the implementation of ZnRequest>>#setBasicAuthenticationUsername:password:

Basic authentication over plain HTTP is insecure because it transfers your username/password combination obfuscated by encoding it using the trivial Base64 encoding. When used over HTTPS, basic authentication is secure though.

Note that when sending multiple requests while reusing the same client, authentication is reset for each request, to prevent the accidental transfer of sensitive data.

Beware that basic authentication is not the same as a web application where you have to log in using a form. See the subsection about cookies and sessions for an example of how this works.
