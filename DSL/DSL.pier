Crafting an Embedded DSL


In this chapter we will develop a simple DSL for rolling dice. An example of such DSL is ==2 D20 + 1 D6== which means that we should roll two times a 20-faces dice and one time a 6 faces dice. This chapter will show how we can (1) simply reuse traditional operator such as ==+==, (2) develop an embedded DSL and show a usage of class extensions.


! Getting started



!! Defining the class Dice


[[[
Object subclass: #Dice
	instanceVariableNames: 'faces'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Dice rolling'
]]]


in the initialize release category define the method ==initialize== as follows
[[[
Dice>>initialize 
	super initialize.
	faces := 6
]]]

To roll a dice we will use the method from Number ==atRandom== which draw randomly a 
number between one and the receiver. 

[[[
Dice>>roll

	^ faces atRandom
]]]

Now we can create an instance ==Dice new== and send it the message  ==roll== and get a result.
Do ==Dice new inspect== and then type in the bottom pane ==self roll==.

We would like to get a simpler way to create Dice. We define the class method ==faces:== as follows

[[[
Dice>>faces: aNumber
	
	^ self new faces: aNumber; yourself
]]]

This method is strictly equivalent to the one below that creates an instance, then set the number of faces of the receiver and finally return the newly instance. 
[[[
Dice>>faces: aNumber

	| instance |
	instance := self new.
	instance faces: aNumber.
	^ instance
]]]

Since we did not create yet the method ==faces:== this is now the time to define it.


[[[
Dice>>faces: aNumber

	faces := aNumber
]]]


Now you can create an instance executing ==Dice faces: 10== and get a 10 faces dice. 



[[[
TestCase subclass: #DiceTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RolePlaying'
]]]







[[[
DiceTest>>testCreationIsOk
	
		self shouldnt: [ Dice faces: 10 ] raise: Error
]]]

! Handle of Dice

[[[
Object subclass: #DiceHandle
	instanceVariableNames: 'dice'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RolePlaying'
]]]

[[[
DiceHandle>>initialize
	super initialize.
	dice := OrderedCollection new.
]]]

[[[
DiceHandle>>addDice: aDice 
	dice add: aDice
]]]

!! Creating a Handle

[[[
DiceHandle new 
	addDice: (Dice faces: 6);
	addDice: (Dice faces: 10);
	yourself
]]]

Now when you open an inspector you cannot see well the dice. so we will enhance the ==printOn:== method.


[[[
Dice>>printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' (', faces printString, ')'
]]]


!! Testing Handle Dice
[[[
TestCase subclass: #DiceHandleTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'RolePlaying'
]]]

[[[
DiceHandleTest>>testCreationIsOk

	| handle |
	handle := DiceHandle new 
			addDice: (Dice faces: 6);
			addDice: (Dice faces: 10);
			yourself.
	self assert: handle diceNumber = 2.
]]]

Now we should add the method diceNumber to the ==DiceHandle==
[[[
DiceHandle>>diceNumber  

	^ dice size
]]]

Now we can define the rolling of a handle of dice by simply summing the dice roll.
[[[
DiceHandle>>roll
	
	| res |
	res := 0.
	dice do: [ :each | res := res + each roll ].
	^ res
]]]

[[[
$a ctrl. "a modified key combination for Ctrl+A"
$a ctrl shift.   "a modified key combination for Ctrl+Shift+A"
]]]

[[[
$a ctrl. "a modified key combination for Ctrl+A"
$a ctrl shift.   "a modified key combination for Ctrl+Shift+A"
]]]

[[[
$a ctrl. "a modified key combination for Ctrl+A"
$a ctrl shift.   "a modified key combination for Ctrl+Shift+A"
]]]

[[[
$a ctrl. "a modified key combination for Ctrl+A"
$a ctrl shift.   "a modified key combination for Ctrl+Shift+A"
]]]

[[[
$a ctrl. "a modified key combination for Ctrl+A"
$a ctrl shift.   "a modified key combination for Ctrl+Shift+A"
]]]


important
It is important to notice that all key combinations are not case sensitive. It takes a and A characters as the same, since they are the same key.

Have you ever used emacs, Eclipse or Visual Studio? Then you probably know sequences of key combinations that launch one only action. Like Alt\+Shift\+X, T (to run JUnit tests in eclipse)? So keymappings can do that too:

[[[
$a command shift, $b shift. "key sequence (Cmd+Shift+A, Shift+B)"
]]]

Sometimes, you want to configure an action to be activated in two different cases. Those are Keymapping options, and get activated when one of the options gets activated:

[[[
$a command | $b command          "key combination (Cmd+A or Cmd+B)"
]]]

Finally, since Pharo is a cross platform system and it is important to provide a good user experience by with the most suitable shortcut layout, keymapping implements platform specific shortcuts, which get activated only when running in the specific platform:

[[[
$a command win | $b command unix     "Cmd+A on windows, but Cmd+B on unix"
]]]

!! Shortcut configurations

Now you know how to build key combinations for your purposes, you probably want to go to the action. Map those combinations to actions and make them work!

!!!Single shortcut configuration

The simplest way to attach a shortcut to a morph is by sending him the ==on:do:== message. The first argument expected is a key combination and the second one is an action. In the example below, a workspace is created with two shortcuts:


- when Cmd\+Shift\+A is pressed, the workspace is deleted
- when Cmd\+Shift\+D is pressed, an information growl should appear yelling 'this shortcut works!'

[[[ 
w:= Workspace new.
morph := w openLabel: 'keymapping test'.
morph on: $a shift command do: [ morph delete ].
morph on: $d shift command do: [ UIManager default inform: 'this shortcut works!' ].
]]]

Easy, huh? So let's move on...


!!!Shortcut categories

Sometimes you want to group and organize shortcuts in a meaningful way and apply them all together on a morph. Sometimes you want some morphs from different hierarchies to share the same group of shortcuts easily. Those groups of shortcuts are what keymapping calls Categories. A category is a group of shortcuts, so far (will change in the future) defined statically by using a keymap pragma on class side:

[[[
"defining a category"
SystemWindow class>>buildShortcutsOn: aBuilder 
     <keymap>
]]]

A class side method marked as ==<keymap>== will be called with a builder object, which can be used to define a named set of shortcuts:

[[[ 
SystemWindow class>>buildShortcutsOn: aBuilder 
    <keymap>
    (aBuilder shortcut:  #close) 
         category:  WindowShortcuts
         default: $w ctrl | $w command mac 
         do: [ :target | target delete ] 
         description: 'Close this window'.
]]]

Shortcuts defined through the builder specify the name of the category they belong to, a default key combination, an action, and a description. All this metadata is there to be used as settings in the future.

Finally  to get your morph handle those shortcuts you can use the ==attachKeymapCategory:== message as in:

[[[
w:= Workspace#new.
morph:= w openLabel: 'keymapping test'. 
morph attachKeymapCategory: #Growling.
]]]


remove a key binding ???

!!Bubbling

Keymappings' shortcuts bubble to their parent (sd: which one?) if not handled, up until the main world morph. That has two main consequences:

- Shortcuts for your application can be designed in a hierarchical way and;
- Every time a shortcut does not work for you, it means that a morph below you has handled it ;) (be careful with text editors that handle many of key combinations)

SD: can't we disable them?

% Local Variables:
% eval: (flyspell-mode -1)
% End:
